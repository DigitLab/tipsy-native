{"version":3,"names":[],"mappings":"","sources":["tipsy.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = require('./utils.js');\n\nvar Utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar defaults = {\n    className: null,\n    delayIn: 0,\n    delayOut: 0,\n    fade: false,\n    fallback: '',\n    gravity: 'n',\n    html: false,\n    offset: 0,\n    opacity: 0.8,\n    title: 'title',\n    trigger: 'hover'\n};\n\nvar tipsyObserver;\n\nvar Tipsy = function () {\n    function Tipsy(element, options) {\n        _classCallCheck(this, Tipsy);\n\n        this.element = element;\n        this.options = Utils.extend({}, defaults, options || {});\n        this.enabled = true;\n\n        this.fixTitle();\n        this.attachEvents();\n    }\n\n    // Static API\n\n\n    _createClass(Tipsy, [{\n        key: 'enable',\n\n\n        // Public API\n        value: function enable() {\n            this.enabled = true;\n        }\n    }, {\n        key: 'disable',\n        value: function disable() {\n            this.enabled = false;\n        }\n    }, {\n        key: 'show',\n        value: function show() {\n            var title = this.getTitle();\n\n            if (!title || !this.enabled) return;\n\n            var gravity = Utils.callOrReturn(this.options.gravity, this.element);\n            var tip = this.getTip();\n            var tipArrow = tip.querySelector('.tipsy-arrow');\n\n            tip.querySelector('.tipsy-inner')[this.options.html ? 'innerHTML' : 'textContent'] = title;\n            this.resetTip();\n\n            document.body.appendChild(tip);\n\n            Utils.css(tip, this.calculateTipPosition(tip, gravity));\n\n            tip.classList.add('tipsy-' + gravity);\n            tipArrow.className = 'tipsy-arrow tipsy-arrow-' + gravity.charAt(0);\n            if (this.options.className) {\n                tip.classList.add(Utils.callOrReturn(this.options.className, this.element));\n            }\n\n            Utils.css(tip, { visibility: 'visible', opacity: this.options.opacity });\n        }\n    }, {\n        key: 'hide',\n        value: function hide() {\n            var tip = this.getTip();\n\n            if (this.options.fade) {\n                tip.addEventListener('transitionend', this.onTransitionEnd);\n                tip.style.opacity = 0;\n            } else {\n                tip.remove();\n            }\n        }\n    }, {\n        key: 'validate',\n        value: function validate() {\n            if (!this.element.parentNode) {\n                this.hide();\n                this.element = null;\n                this.options = null;\n            }\n        }\n\n        // Private methods\n\n    }, {\n        key: 'attachEvents',\n        value: function attachEvents() {\n            // Fix event binding\n            this.onEnter = this.onEnter.bind(this);\n            this.onLeave = this.onLeave.bind(this);\n            this.onTransitionEnd = this.onTransitionEnd.bind(this);\n\n            if (this.options.trigger != 'manual') {\n                var eventIn = this.options.trigger == 'hover' ? 'mouseenter' : 'focus';\n                var eventOut = this.options.trigger == 'hover' ? 'mouseleave' : 'blur';\n\n                this.element.addEventListener(eventIn, this.onEnter);\n                this.element.addEventListener(eventOut, this.onLeave);\n            }\n        }\n    }, {\n        key: 'onEnter',\n        value: function onEnter() {\n            var self = this;\n\n            this.hoverState = 'in';\n            if (this.options.delayIn == 0) {\n                this.show();\n            } else {\n                setTimeout(function () {\n                    if (self.hoverState == 'in') {\n                        self.show();\n                    }\n                }, this.options.delayIn);\n            }\n        }\n    }, {\n        key: 'onLeave',\n        value: function onLeave() {\n            var self = this;\n\n            this.hoverState = 'out';\n            if (this.options.delayOut == 0) {\n                this.hide();\n            } else {\n                setTimeout(function () {\n                    if (self.hoverState == 'out') {\n                        self.hide();\n                    }\n                }, this.options.delayOut);\n            }\n        }\n    }, {\n        key: 'onTransitionEnd',\n        value: function onTransitionEnd(event) {\n            event.target.removeEventListener('transitionend', this.onTransitionEnd);\n            event.target.remove();\n        }\n    }, {\n        key: 'calculateTipPosition',\n        value: function calculateTipPosition(tip, gravity) {\n            var actualWidth = tip.offsetWidth;\n            var actualHeight = tip.offsetHeight;\n            var pos = Utils.extend({}, Utils.offset(this.element), {\n                height: this.element.offsetHeight,\n                width: this.element.offsetWidth\n            });\n            var tipPos;\n\n            switch (gravity.charAt(0)) {\n                case 'n':\n                    tipPos = { top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2 };\n                    break;\n\n                case 's':\n                    tipPos = { top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2 };\n                    break;\n\n                case 'e':\n                    tipPos = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset };\n                    break;\n\n                case 'w':\n                    tipPos = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset };\n                    break;\n            }\n\n            if (gravity.length == 2) {\n                if (gravity.charAt(1) == 'w') {\n                    tipPos.left = pos.left + pos.width / 2 - 15;\n                } else {\n                    tipPos.left = pos.left + pos.width / 2 - actualWidth + 15;\n                }\n            }\n\n            return tipPos;\n        }\n    }, {\n        key: 'getTitle',\n        value: function getTitle() {\n            var title;\n            var options = this.options;\n\n            this.fixTitle();\n\n            if (typeof options.title == 'string') {\n                title = this.element.getAttribute(options.title == 'title' ? 'original-title' : options.title);\n            } else if (typeof options.title == 'function') {\n                title = options.title.call(this.element);\n            }\n\n            title = ('' + title).replace(/(^\\s*|\\s*$)/, \"\");\n\n            return title || options.fallback;\n        }\n    }, {\n        key: 'getTip',\n        value: function getTip() {\n            if (!this.tip) {\n                this.tip = document.createElement('div');\n                this.tip.classList.add('tipsy');\n                this.tip.innerHTML = '<div class=\"tipsy-arrow\"></div><div class=\"tipsy-inner\"></div>';\n                this.tip.pointee = this.element;\n\n                if (this.options.fade) {\n                    this.tip.style.transition = 'opacity .25s';\n                }\n            }\n\n            return this.tip;\n        }\n    }, {\n        key: 'resetTip',\n        value: function resetTip() {\n            if (this.tip) {\n                this.tip.remove();\n\n                this.tip.className = 'tipsy';\n                this.tip.removeEventListener('transitionend', this.onTransitionEnd);\n                Utils.css(this.tip, { top: 0, left: 0, display: 'block', opacity: 0, visibility: 'hidden' });\n            }\n        }\n    }, {\n        key: 'fixTitle',\n        value: function fixTitle() {\n            var title = this.element.getAttribute('title');\n            var originalTitle = this.element.getAttribute('original-title');\n\n            if (title || typeof originalTitle != 'string') {\n                this.element.setAttribute('original-title', title || '');\n                this.element.removeAttribute('title');\n            }\n        }\n    }], [{\n        key: 'bind',\n        value: function bind(element, options) {\n            if (element && !element.tipsy) {\n                element.tipsy = new Tipsy(element, options);\n            }\n        }\n    }, {\n        key: 'bindSelector',\n        value: function bindSelector(selector, options, node) {\n            node = node || document;\n\n            var elements = node.querySelectorAll(selector);\n            [].forEach.call(elements, function (element) {\n                Tipsy.bind(element, options);\n            });\n        }\n    }, {\n        key: 'watchSelector',\n        value: function watchSelector(selector, options, node) {\n            node = node || document;\n            Tipsy.bindSelector(selector, options, node);\n\n            tipsyObserver = new MutationObserver(function (mutations) {\n                mutations.forEach(function (mutation) {\n                    var addedNodes = mutation.addedNodes;\n                    if (addedNodes && addedNodes.length) {\n                        [].forEach.call(addedNodes, function (node) {\n                            if (node.matches(selector)) {\n                                Tipsy.bind(node, options);\n                                return;\n                            }\n\n                            var elements = node.querySelectorAll(selector);\n                            [].forEach.call(elements, function (element) {\n                                Tipsy.bind(element, options);\n                            });\n                        });\n                    }\n                });\n            });\n            tipsyObserver.observe(node, { childList: true, subtree: true });\n        }\n    }, {\n        key: 'autoNS',\n        value: function autoNS() {\n            var offset = Utils.offset(this);\n\n            return offset.top > document.body.scrollTop + window.innerHeight / 2 ? 's' : 'n';\n        }\n    }, {\n        key: 'autoWE',\n        value: function autoWE() {\n            var offset = Utils.offset(this);\n\n            return offset.left > document.body.scrollLeft + window.innerWidth / 2 ? 's' : 'n';\n        }\n    }]);\n\n    return Tipsy;\n}();\n\nwindow.Tipsy = Tipsy;\n\n},{\"./utils.js\":2}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.callOrReturn = callOrReturn;\nexports.css = css;\nexports.extend = extend;\nexports.offset = offset;\n/**\n * CSS properties that should have 'px' attached.\n *\n * @type {string[]}\n */\nvar pixelProperties = ['top', 'left', 'width', 'height'];\n\n/**\n * Call the value if it is a function, otherwise returns the value.\n *\n * @param value\n * @param ctx\n * @returns {*}\n */\nfunction callOrReturn(value, ctx) {\n    if (typeof value == 'function') {\n        return value.call(ctx);\n    }\n\n    return value;\n}\n\n/**\n * Modifies the css of the element.\n *\n * @param element\n * @param css\n */\nfunction css(element, css) {\n    for (var prop in css) {\n        if (pixelProperties.indexOf(prop) >= 0 && css[prop] != 0) {\n            css[prop] = css[prop] + 'px';\n        }\n\n        element.style[prop] = css[prop];\n    }\n}\n\n/**\n * Extends an object with other objects.\n *\n * @returns {*}\n */\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        for (var key in arguments[i]) {\n            if (arguments[i].hasOwnProperty(key)) {\n                arguments[0][key] = arguments[i][key];\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\n/**\n * Gets the offset of an element.\n *\n * @param element\n * @returns {{top: number, left: number}}\n */\nfunction offset(element) {\n    var rect = element.getBoundingClientRect();\n\n    return {\n        top: rect.top + document.body.scrollTop,\n        left: rect.left + document.body.scrollLeft\n    };\n}\n\n},{}]},{},[1]);\n"],"file":"tipsy.js","sourceRoot":"/source/"}